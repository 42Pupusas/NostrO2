use bech32::{Bech32, Hrp};
use bip39::Language;

use secp256k1::{rand::rngs::OsRng, Keypair, Secp256k1};

#[derive(Debug, PartialEq, Clone, Eq)]
pub struct NostrKeypair {
    keypair: Keypair,
    extractable: bool,
}

impl NostrKeypair {
    pub fn generate(extractable: bool) -> Self {
        let keypair = Keypair::new(&Secp256k1::signing_only(), &mut OsRng);
        Self {
            keypair,
            extractable,
        }
    }
    pub fn make_extractable(&mut self) {
        self.extractable = true;
    }
    #[must_use]
    pub fn public_key(&self) -> String {
        self.keypair.public_key().x_only_public_key().0.to_string()
    }
    #[must_use]
    pub fn public_key_slice(&self) -> [u8; 32] {
        self.keypair.public_key().x_only_public_key().0.serialize()
    }
    /// Get the public key as a bech32 string
    /// starting with "npub"
    ///
    /// # Errors
    ///
    /// Should never fail unless the keypair is invalid, which should never happen
    /// as the keypair is generated by the library
    pub fn npub(&self) -> Result<String, Box<dyn std::error::Error>> {
        let hrp = Hrp::parse("npub")?;
        let pk_data = self.keypair.public_key().x_only_public_key().0.serialize();
        Ok(bech32::encode::<Bech32>(hrp, &pk_data)?)
    }
    pub fn sign_nostr_event(&self, note: &mut nostro2::note::NostrNote) {
        if note.serialize_id().is_ok() {
            let secp = Secp256k1::signing_only();
            let sig = secp
                .sign_schnorr_no_aux_rand(
                    note.id_bytes().as_ref().unwrap_or(&[0_u8; 32]),
                    &self.keypair,
                )
                .to_string();
            note.sig = Some(sig);
        }
    }
    /// Get the shared secret point between the private keypair and a public key
    ///
    /// # Errors
    ///
    /// Returns an error if the public key cannot create a shared secret with the private keypair
    /// or if the public key is not in the correct format.
    pub fn get_shared_point(
        &self,
        public_key_string: &str,
    ) -> Result<[u8; 32], Box<dyn std::error::Error>> {
        let hex_pk = Self::hex_decode(public_key_string);
        let x_only_public_key = secp256k1::XOnlyPublicKey::from_slice(hex_pk.as_slice())?;
        let public_key = secp256k1::PublicKey::from_x_only_public_key(
            x_only_public_key,
            secp256k1::Parity::Even,
        );
        let mut ssp = secp256k1::ecdh::shared_secret_point(&public_key, &self.keypair.secret_key())
            .as_slice()
            .to_owned();
        ssp.resize(32, 0); // toss the Y part
        ssp.try_into().map_err(|_| "Invalid shared secret".into())
    }
    /// Encrypt a NIP-04 encrypted plaintext
    ///
    /// # Errors
    ///
    /// Returns an error if the public key cannot create a shared secret with the private keypair,
    /// or if the encryption fails.
    pub fn encrypt_nip_04_plaintext(
        &self,
        plaintext: &str,
        pubkey: String,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let nip_04 = crate::nip_04::Nip04::new(self.clone(), pubkey);
        nip_04.encrypt(plaintext)
    }
    /// Decrypt a NIP-04 encrypted cyphertext
    ///
    /// # Errors
    ///
    /// Returns an error if the public key cannot create a shared secret with the private keypair,
    /// or if the encryption fails.
    pub fn decrypt_nip_04_plaintext(
        &self,
        cyphertext: &str,
        pubkey: String,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let nip_04 = crate::nip_04::Nip04::new(self.clone(), pubkey);
        nip_04.decrypt(cyphertext)
    }
    /// Encrypt a NIP-44 encrypted plaintext
    ///
    /// # Errors
    ///
    /// Returns an error if the public key cannot create a shared secret with the private keypair,
    /// or if the encryption fails.
    pub fn encrypt_nip_44_plaintext(
        &self,
        plaintext: &str,
        pubkey: String,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let nip_44 = crate::nip_44::Nip44::new(self.clone(), pubkey);
        nip_44.nip_44_encrypt(plaintext)
    }
    /// Decrypt a NIP-44 encrypted cyphertext
    ///
    /// # Errors
    ///
    /// Returns an error if the public key cannot create a shared secret with the private keypair,
    /// or if the encryption fails.
    pub fn decrypt_nip_44_plaintext(
        &self,
        cyphertext: &str,
        pubkey: String,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let nip_44 = crate::nip_44::Nip44::new(self.clone(), pubkey);
        nip_44.nip_44_decrypt(cyphertext)
    }
    /// Sign a `NostrNote` with its `content` field encrypted using NIP-04
    ///
    /// # Errors
    ///
    /// Returns an error if the public key cannot create a shared secret with the private keypair,
    /// or if the encryption fails.
    pub fn sign_nip_04_encrypted(
        &self,
        note: &mut nostro2::note::NostrNote,
        pubkey: String,
    ) -> Result<(), Box<dyn std::error::Error>> {
        note.tags.add_pubkey_tag(&pubkey);
        let encrypted_content = self.encrypt_nip_04_plaintext(&note.content, pubkey)?;
        note.content = encrypted_content;
        self.sign_nostr_event(note);
        Ok(())
    }
    /// Sign a NIP-44 encrypted note
    ///
    /// # Errors
    ///
    /// Returns an error if the public key cannot create a shared secret with the private keypair,
    /// or if the encryption fails.
    pub fn decrypt_nip_04_content(
        &self,
        signed_note: &nostro2::note::NostrNote,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let public_key_string = signed_note.pubkey.to_string();

        let plaintext = self.decrypt_nip_04_plaintext(&signed_note.content, public_key_string)?;
        Ok(plaintext)
    }

    /// Signs a NIP-44 encrypted message in the `NostrNote` `content` field
    ///
    /// # Errors
    ///
    /// Returns an error if the public key cannot create a shared secret with the private keypair,
    /// or if the encryption fails.
    pub fn sign_nip_44_encrypted(
        &self,
        note: &mut nostro2::note::NostrNote,
        pubkey: String,
    ) -> Result<(), Box<dyn std::error::Error>> {
        note.tags.add_pubkey_tag(&pubkey);
        let encrypted_content = self.encrypt_nip_44_plaintext(&note.content, pubkey)?;
        note.content = encrypted_content;
        self.sign_nostr_event(note);
        Ok(())
    }

    /// Decrypts a NIP-44 encrypted message from a `NostrNote` `content` field
    ///
    /// # Errors
    ///
    /// Returns an error if the public key cannot create a shared secret with the private keypair,
    /// or if the cyphertext is not in the correct format,
    pub fn decrypt_nip_44_content(
        &self,
        signed_note: &nostro2::note::NostrNote,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let public_key_string = signed_note.pubkey.to_string();
        let plaintext = self.decrypt_nip_44_plaintext(&signed_note.content, public_key_string)?;
        Ok(plaintext)
    }
    #[must_use]
    pub fn get_secret_key(&self) -> [u8; 32] {
        if !self.extractable {
            return [0_u8; 32];
        }
        self.keypair.secret_key().secret_bytes()
    }

    /// Get the secret key as a bech32 string
    /// starting with "nsec"
    ///
    /// # Errors
    ///
    /// Returns an error if the keypair is not extractable
    /// or if the bech32 string cannot be generated
    pub fn get_nsec(&self) -> Result<String, Box<dyn std::error::Error>> {
        if !self.extractable {
            return Err("Not extractable".into());
        }
        let secret_key = self.keypair.secret_key().secret_bytes();
        let hrp = Hrp::parse("nsec").map_err(|_| "Invalid hrp")?;
        let string = bech32::encode::<Bech32>(hrp, &secret_key).map_err(|_| "Invalid bech32")?;
        Ok(string)
    }

    /// Get the mnemonic for the keypair separated by spaces
    ///
    /// # Errors
    ///
    /// Returns an error if the keypair is not extractable
    /// or if the mnemonic cannot be generated
    pub fn get_mnemonic(&self, language: Language) -> Result<String, Box<dyn std::error::Error>> {
        if !self.extractable {
            return Err("Not extractable".into());
        }
        let secret_key = self.keypair.secret_key().secret_bytes();
        let mnemonic = bip39::Mnemonic::from_entropy_in(language, &secret_key)
            .map_err(|_| "Invalid mnemonic")?;
        Ok(mnemonic.words().collect::<Vec<&str>>().join(" "))
    }

    /// Parse a mnemonic 12 or 24 words into a `NostrKeypair`
    /// separated by spaces
    ///
    /// # Errors
    ///
    /// Returns an error if the mnemonic is invalid
    /// or if the mnemonic is not extractable
    pub fn parse_mnemonic(
        mnemonic: &str,
        language: Language,
        extractable: bool,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let mnemonic =
            bip39::Mnemonic::parse_in(language, mnemonic).map_err(|_| "Invalid mnemonic")?;
        let keypair: Self = mnemonic.try_into()?;
        if extractable {
            let mut keypair = keypair;
            keypair.make_extractable();
            Ok(keypair)
        } else {
            Ok(keypair)
        }
    }
    fn hex_decode(hex_string: &str) -> Vec<u8> {
        hex_string
            .as_bytes()
            .chunks(2)
            .filter_map(|b| u8::from_str_radix(std::str::from_utf8(b).ok()?, 16).ok())
            .collect()
    }
}
impl TryFrom<&[u8]> for NostrKeypair {
    type Error = Box<dyn std::error::Error>;
    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        let keypair = Keypair::from_seckey_slice(&Secp256k1::signing_only(), value)
            .map_err(|_| "Invalid secret key")?;
        Ok(Self {
            keypair,
            extractable: false,
        })
    }
}
impl From<[u8; 64]> for NostrKeypair {
    fn from(value: [u8; 64]) -> Self {
        let keypair = Keypair::from_seckey_slice(&Secp256k1::signing_only(), &value)
            .expect("Could not create signing key");
        Self {
            keypair,
            extractable: false,
        }
    }
}
impl From<&[u8; 64]> for NostrKeypair {
    fn from(value: &[u8; 64]) -> Self {
        let keypair = Keypair::from_seckey_slice(&Secp256k1::signing_only(), value)
            .expect("Could not create signing key");
        Self {
            keypair,
            extractable: false,
        }
    }
}
impl TryFrom<&str> for NostrKeypair {
    type Error = Box<dyn std::error::Error>;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        if value.starts_with("nsec") {
            let (hrp, data) = bech32::decode(value).map_err(|_| "Invalid bech32 string")?;
            if hrp.to_string() != "nsec" {
                return Err("Invalid nsec key".into());
            }
            Self::try_from(data.as_slice())
        } else {
            let hex = Self::hex_decode(value);
            Self::try_from(hex.as_slice())
        }
    }
}
impl TryFrom<bip39::Mnemonic> for NostrKeypair {
    type Error = Box<dyn std::error::Error>;
    fn try_from(value: bip39::Mnemonic) -> Result<Self, Self::Error> {
        Self::try_from(value.to_entropy().as_slice())
    }
}
impl TryFrom<String> for NostrKeypair {
    type Error = Box<dyn std::error::Error>;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::try_from(value.as_str())
    }
}
impl TryFrom<&String> for NostrKeypair {
    type Error = Box<dyn std::error::Error>;
    fn try_from(value: &String) -> Result<Self, Self::Error> {
        Self::try_from(value.as_str())
    }
}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_user_keys() {
        let user_keys = NostrKeypair::try_from(
            "a992011980303ea8c43f66087634283026e7796e7fcea8b61710239e19ee28c8",
        )
        .expect("Failed to create NostrKeypair!");
        let public_key = user_keys.public_key();
        assert_eq!(
            public_key,
            "689403d3808274889e371cfe53c2d78eb05743a964cc60d3b2e55824e8fe740a"
        );
        let npub = user_keys.npub().expect("Failed to create npub!");
        assert_eq!(
            npub,
            "npub1dz2q85uqsf6g383hrnl98skh36c9wsafvnxxp5aju4vzf687ws9q7zr8df"
        );
        let nsec_key = NostrKeypair::try_from(
            "nsec14xfqzxvqxql233plvcy8vdpgxqnww7tw0l823dshzq3eux0w9ryqulcv53",
        )
        .unwrap();
        let nsec_pubkey = nsec_key.public_key();
        let nsec_npub = nsec_key.npub().expect("Failed to create npub!");
        assert_eq!(nsec_pubkey, public_key);
        assert_eq!(nsec_npub, npub);
    }

    #[test]
    fn test_mnemonic() {
        let user_keys = NostrKeypair::generate(true);
        let mnemonic = user_keys.get_mnemonic(Language::English).unwrap();
        let spanish_mnemonic = user_keys.get_mnemonic(Language::Spanish).unwrap();
        assert_eq!(
            NostrKeypair::parse_mnemonic(&mnemonic, Language::English, false)
                .unwrap()
                .public_key(),
            user_keys.public_key()
        );
        assert_eq!(
            NostrKeypair::parse_mnemonic(&spanish_mnemonic, Language::Spanish, false)
                .unwrap()
                .public_key(),
            user_keys.public_key()
        );
    }

    #[test]
    fn test_extractable() {}

    #[test]
    fn test_encryption() {
        let user_keys = NostrKeypair::generate(false);
        let client_keys = NostrKeypair::generate(false);
        let mut note_request = nostro2::note::NostrNote {
            pubkey: user_keys.public_key(),
            kind: 24133,
            content: "test".to_string(),
            ..Default::default()
        };
        user_keys
            .sign_nip_04_encrypted(&mut note_request, client_keys.public_key())
            .unwrap();
        let decrypted = client_keys.decrypt_nip_04_content(&note_request).unwrap();
        assert_eq!(decrypted, "test");

        let mut nip_44_note_request = nostro2::note::NostrNote {
            pubkey: user_keys.public_key(),
            kind: 24133,
            content: "test".to_string(),
            ..Default::default()
        };
        user_keys
            .sign_nip_44_encrypted(&mut nip_44_note_request, client_keys.public_key())
            .expect("");
        let decrypted_nip_44 = client_keys
            .decrypt_nip_44_content(&nip_44_note_request)
            .expect("");
        assert_eq!(decrypted_nip_44, "test");
    }
}
