use nostro2::NostrSigner;
use nostro2_nips::{Nip04, Nip44, Nip59};
use zeroize::Zeroize;

use crate::errors::NostrKeypairError;

pub enum EncryptionScheme {
    Nip04,
    Nip44,
}
pub enum GiftwrapScheme {
    Persistent,
    Replaceable,
    Ephemeral,
    Parameterized(String),
}
#[derive(Debug, PartialEq, Clone, Eq)]
pub struct NostrKeypair {
    keypair: secp256k1::Keypair,
    extractable: bool,
}
impl NostrKeypair {
    pub fn set_extractable(&mut self, extractable: bool) {
        self.extractable = extractable;
    }
    #[must_use]
    pub fn public_key_slice(&self) -> [u8; 32] {
        self.keypair.public_key().x_only_public_key().0.serialize()
    }
    #[must_use]
    pub fn public_key(&self) -> String {
        hex::encode(self.keypair.x_only_public_key().0.serialize())
    }
    /// Get the public key as a bech32 string
    /// starting with "npub"
    ///
    /// # Errors
    ///
    /// Should never fail unless the keypair is invalid, which should never happen
    /// as the keypair is generated by the library
    pub fn npub(&self) -> Result<String, NostrKeypairError> {
        let hrp = bech32::Hrp::parse("npub").map_err(|_| NostrKeypairError::HrpParseError)?;
        Ok(bech32::encode::<bech32::Bech32>(
            hrp,
            &self.keypair.x_only_public_key().0.serialize(),
        )?)
    }
    /// Sign a note
    ///
    /// # Errors
    ///
    pub fn sign_note(&self, note: &mut nostro2::note::NostrNote) -> Result<(), NostrKeypairError> {
        self.sign_nostr_note(note)?;
        Ok(())
    }
    /// Sign and encrypt a note
    ///
    /// # Errors
    ///
    /// Returns an error if the encryption scheme is not supported
    /// or if the note cannot be encrypted
    pub fn sign_encrypted_note(
        &self,
        note: &mut nostro2::note::NostrNote,
        peer_pubkey: &str,
        encryption_scheme: &EncryptionScheme,
    ) -> Result<(), NostrKeypairError> {
        let mut buffer: zeroize::Zeroizing<Vec<u8>> = zeroize::Zeroizing::new(Vec::new());
        match encryption_scheme {
            EncryptionScheme::Nip04 => self.nip04_encrypt_note(note, peer_pubkey)?,
            EncryptionScheme::Nip44 => {
                self.nip44_encrypt_note(note, peer_pubkey)?;
            }
        }
        buffer.zeroize();
        self.sign_nostr_note(note)?;
        Ok(())
    }
    /// Decrypt a note
    ///
    /// # Errors
    ///
    /// Returns an error if the encryption scheme is not supported
    /// or if the note cannot be decrypted
    pub fn decrypt_note<'a>(
        &self,
        note: &'a nostro2::note::NostrNote,
        peer_pubkey: &'a str,
        encryption_scheme: &EncryptionScheme,
    ) -> Result<std::borrow::Cow<'a, str>, NostrKeypairError> {
        match encryption_scheme {
            EncryptionScheme::Nip04 => Ok(self.nip04_decrypt_note(note, peer_pubkey)?),
            EncryptionScheme::Nip44 => Ok(self.nip44_decrypt_note(note, peer_pubkey)?),
        }
    }
    /// Giftwrap a note
    ///
    /// - A `rumor` is a regular nostr event, but is not signed. This means that if it is leaked, it cannot be verified.
    /// - A `rumor` is serialized to JSON, encrypted, and placed in the `content` field of a `seal`.
    ///   The `seal` is then signed by the author of the note. The only information publicly available on a `seal` is who signed it, but not what was said.
    /// - A `seal` is serialized to `JSON`, encrypted, and placed in the `content` field of a `gift wrap`.
    ///
    /// # Errors
    ///
    /// Returns an error if the encryption scheme is not supported
    /// or if the note cannot be encrypted.
    pub fn giftwrap_note(
        &self,
        note: &mut nostro2::note::NostrNote,
        peer_pubkey: &str,
        scheme: &GiftwrapScheme,
    ) -> Result<nostro2::note::NostrNote, NostrKeypairError> {
        match scheme {
            GiftwrapScheme::Persistent => Ok(self.giftwrap(note, peer_pubkey)?),
            GiftwrapScheme::Replaceable => Ok(self.replaceable_giftwrap(note, peer_pubkey)?),
            GiftwrapScheme::Ephemeral => Ok(self.ephemeral_giftwrap(note, peer_pubkey)?),
            GiftwrapScheme::Parameterized(tag) => {
                Ok(self.parameterized_giftwrap(note, peer_pubkey, tag)?)
            }
        }
    }
    pub fn extract_rumor(
        &self,
        note: nostro2::note::NostrNote,
    ) -> Result<nostro2::note::NostrNote, NostrKeypairError> {
        Ok(self.rumor(&note)?)
    }
    /// Get the shared secret point between the private keypair and a public key
    ///
    /// # Errors
    ///
    /// Returns an error if the public key cannot create a shared secret with the private keypair
    /// or if the public key is not in the correct format.
    pub fn shared_point(&self, public_key_string: &str) -> Result<[u8; 32], NostrKeypairError> {
        let hex_pk = hex::decode(public_key_string)?;
        let x_only_public_key = secp256k1::XOnlyPublicKey::from_slice(hex_pk.as_slice())?;
        let public_key = secp256k1::PublicKey::from_x_only_public_key(
            x_only_public_key,
            secp256k1::Parity::Even,
        );
        let shared_point_full =
            secp256k1::ecdh::shared_secret_point(&public_key, &self.keypair.secret_key());
        let mut point = [0_u8; 32];
        point.copy_from_slice(&shared_point_full.as_slice()[..32]);
        Ok(point)
    }
    #[must_use]
    pub fn secret_key(&self) -> [u8; 32] {
        let mut out = [0_u8; 32];
        if self.extractable {
            out.copy_from_slice(&self.keypair.secret_key().secret_bytes());
        }
        out
    }
    /// Get the secret key as a bech32 string
    /// starting with "nsec"
    ///
    /// # Errors
    ///
    /// Returns an error if the keypair is not extractable
    /// or if the bech32 string cannot be generated
    pub fn nsec(&self) -> Result<String, NostrKeypairError> {
        if !self.extractable {
            return Err(NostrKeypairError::NotExtractable);
        }
        let secret_key = self.keypair.secret_key().secret_bytes();
        let hrp = bech32::Hrp::parse("nsec").map_err(|_| NostrKeypairError::HrpParseError)?;
        let string = bech32::encode::<bech32::Bech32>(hrp, &secret_key)?;
        Ok(string)
    }

    /// Get the mnemonic for the keypair separated by spaces
    ///
    /// # Errors
    ///
    /// Returns an error if the keypair is not extractable
    /// or if the mnemonic cannot be generated
    pub fn mnemonic(&self, language: bip39::Language) -> Result<String, NostrKeypairError> {
        if !self.extractable {
            return Err(NostrKeypairError::NotExtractable);
        }
        let secret_key = self.keypair.secret_key().secret_bytes();
        let mnemonic = bip39::Mnemonic::from_entropy_in(language, &secret_key)?;
        let mut out = String::with_capacity(256); // heuristically sized
        for word in mnemonic.words() {
            out.push_str(word);
            out.push(' ');
        }
        out.pop(); // remove trailing space
        Ok(out)
    }

    /// Parse a mnemonic 12 or 24 words into a `NostrKeypair`
    /// separated by spaces
    ///
    /// # Errors
    ///
    /// Returns an error if the mnemonic is invalid
    /// or if the mnemonic is not extractable
    pub fn parse_mnemonic(
        mnemonic: &str,
        language: bip39::Language,
        extractable: bool,
    ) -> Result<Self, NostrKeypairError> {
        let mnemonic = bip39::Mnemonic::parse_in(language, mnemonic)?;
        let keypair: Self = mnemonic.try_into()?;
        if extractable {
            let mut keypair = keypair;
            keypair.extractable = true;
            Ok(keypair)
        } else {
            Ok(keypair)
        }
    }
}
impl nostro2_nips::Nip04 for NostrKeypair {
    fn shared_secret(
        &self,
        public_key_string: &str,
    ) -> Result<zeroize::Zeroizing<[u8; 32]>, nostro2_nips::Nip04Error> {
        Ok(self.shared_point(public_key_string)?.into())
    }
}
impl nostro2_nips::Nip44 for NostrKeypair {
    fn shared_secret(
        &self,
        public_key_string: &str,
    ) -> Result<zeroize::Zeroizing<[u8; 32]>, nostro2_nips::Nip44Error> {
        Ok(self.shared_point(public_key_string)?.into())
    }
}
impl nostro2_nips::Nip17 for NostrKeypair {}
impl nostro2_nips::Nip46 for NostrKeypair {}
impl nostro2_nips::Nip59 for NostrKeypair {}
impl nostro2_nips::Nip82 for NostrKeypair {}
impl nostro2::NostrSigner for NostrKeypair {
    fn sign_nostr_note(
        &self,
        note: &mut nostro2::note::NostrNote,
    ) -> Result<(), nostro2::errors::NostrErrors> {
        note.pubkey = self.public_key();
        note.serialize_id()?;
        let sig = crate::SECP
            .sign_schnorr_no_aux_rand(
                note.id_bytes().as_ref().unwrap_or(&[0_u8; 32]),
                &self.keypair,
            )
            .to_string();
        note.sig.replace(sig);
        Ok(())
    }
    fn generate(extractable: bool) -> Self {
        let keypair = secp256k1::Keypair::new(&crate::SECP, &mut secp256k1::rand::rngs::OsRng);
        Self {
            keypair,
            extractable,
        }
    }
    fn public_key(&self) -> String {
        hex::encode(self.keypair.x_only_public_key().0.serialize())
    }
    fn secret_key(&self) -> String {
        hex::encode(self.keypair.secret_key().secret_bytes())
    }
}

impl TryFrom<&[u8]> for NostrKeypair {
    type Error = NostrKeypairError;
    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        let keypair = secp256k1::Keypair::from_seckey_slice(&crate::SECP, value)?;
        Ok(Self {
            keypair,
            extractable: false,
        })
    }
}
impl std::str::FromStr for NostrKeypair {
    type Err = NostrKeypairError;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        if value.starts_with("nsec") {
            let (hrp, data) = bech32::decode(value)?;
            if hrp.to_string() != "nsec" {
                return Err(NostrKeypairError::HrpParseError);
            }
            Self::try_from(data.as_slice())
        } else {
            let hex = hex::decode(value)?;
            Self::try_from(hex.as_slice())
        }
    }
}
impl TryFrom<bip39::Mnemonic> for NostrKeypair {
    type Error = NostrKeypairError;
    fn try_from(value: bip39::Mnemonic) -> Result<Self, Self::Error> {
        Self::try_from(value.to_entropy().as_slice())
    }
}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_keypair() {
        let kp = NostrKeypair::generate(true);
        assert_eq!(kp.secret_key().len(), 32);
        assert_eq!(kp.public_key_slice().len(), 32);
    }

    #[test]
    fn test_bech32_encoding_decoding() {
        let kp = NostrKeypair::generate(true);
        let nsec = kp.nsec().unwrap();
        let npub = kp.npub().unwrap();

        let restored_kp = nsec.parse::<NostrKeypair>().unwrap();
        assert_eq!(restored_kp.public_key(), kp.public_key());
        assert_eq!(restored_kp.npub().unwrap(), npub);
    }

    #[test]
    fn test_secret_key_extraction_protection() {
        let kp = NostrKeypair::generate(false);
        assert_eq!(kp.secret_key(), [0u8; 32]);
        assert!(kp.nsec().is_err());
        assert!(kp.mnemonic(bip39::Language::English).is_err());
    }

    #[test]
    fn test_mnemonic_roundtrip() {
        let kp = NostrKeypair::generate(true);
        let mnemonic = kp.mnemonic(bip39::Language::English).unwrap();
        let restored_kp =
            NostrKeypair::parse_mnemonic(&mnemonic, bip39::Language::English, true).unwrap();
        assert_eq!(restored_kp.secret_key(), kp.secret_key());
        assert_eq!(restored_kp.public_key(), kp.public_key());
    }

    #[test]
    fn test_invalid_key_input() {
        assert!("invalid".parse::<NostrKeypair>().is_err());
        assert!("nsec1invalid".parse::<NostrKeypair>().is_err());
        assert!(NostrKeypair::parse_mnemonic("foo bar", bip39::Language::English, true).is_err());
    }

    #[test]
    fn test_shared_secret_consistency() {
        let alice = NostrKeypair::generate(true);
        let bob = NostrKeypair::generate(true);

        let alice_secret = alice.shared_point(&bob.public_key()).unwrap();
        let bob_secret = bob.shared_point(&alice.public_key()).unwrap();

        assert_eq!(alice_secret, bob_secret);
    }

    #[test]
    fn test_sign_encrypt_note_nip44() {
        let alice = NostrKeypair::generate(true);
        let bob = NostrKeypair::generate(true);

        let mut note = nostro2::note::NostrNote {
            content: "Hello, Bob!".to_string(),
            kind: 1,
            ..Default::default()
        };

        let res = alice.sign_encrypted_note(&mut note, &bob.public_key(), &EncryptionScheme::Nip44);
        assert!(res.is_ok());
        assert!(note.sig.is_some());

        let pubkey = alice.public_key();
        let decrypted_note = bob.decrypt_note(&note, &pubkey, &EncryptionScheme::Nip44);
        assert!(decrypted_note.is_ok());
        assert_eq!(decrypted_note.unwrap(), "Hello, Bob!");
    }

    #[test]
    fn test_user_keys() {
        let user_keys: NostrKeypair =
            "a992011980303ea8c43f66087634283026e7796e7fcea8b61710239e19ee28c8"
                .parse()
                .expect("Failed to create NostrKeypair!");
        let public_key = user_keys.public_key();
        assert_eq!(
            public_key,
            "689403d3808274889e371cfe53c2d78eb05743a964cc60d3b2e55824e8fe740a"
        );
        let npub = user_keys.npub().expect("Failed to create npub!");
        assert_eq!(
            npub,
            "npub1dz2q85uqsf6g383hrnl98skh36c9wsafvnxxp5aju4vzf687ws9q7zr8df"
        );
        let nsec_key = "nsec14xfqzxvqxql233plvcy8vdpgxqnww7tw0l823dshzq3eux0w9ryqulcv53"
            .parse::<NostrKeypair>()
            .expect("Failed to create nsec key!");
        let nsec_pubkey = nsec_key.public_key();
        let nsec_npub = nsec_key.npub().expect("Failed to create npub!");
        assert_eq!(nsec_pubkey, public_key);
        assert_eq!(nsec_npub, npub);
    }

    #[test]
    fn test_mnemonic() {
        let user_keys = NostrKeypair::generate(true);
        let mnemonic = user_keys.mnemonic(bip39::Language::English).unwrap();
        let spanish_mnemonic = user_keys.mnemonic(bip39::Language::Spanish).unwrap();
        assert_eq!(
            NostrKeypair::parse_mnemonic(&mnemonic, bip39::Language::English, false)
                .unwrap()
                .public_key(),
            user_keys.public_key()
        );
        assert_eq!(
            NostrKeypair::parse_mnemonic(&spanish_mnemonic, bip39::Language::Spanish, false)
                .unwrap()
                .public_key(),
            user_keys.public_key()
        );
    }
}
